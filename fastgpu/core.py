#AUTOGENERATED! DO NOT EDIT! File to edit: dev/00_core.ipynb (unless otherwise specified).

__all__ = ['setup_dirs', 'find_next_script', 'safe_rename', 'ResourcePoolBase', 'FixedWorkerPool', 'NVIDIAGPUs']

#Cell
from fastcore.all import *
import pynvml

#Cell
def setup_dirs(path):
    "Create and return the following subdirs of `p`: to_run running complete fail out"
    dirs = L(path/o for o in 'to_run running complete fail out'.split())
    for o in dirs: o.mkdir(exist_ok=True)
    return dirs

#Cell
def find_next_script(p):
    files = p.ls().sorted().filter(Self.is_file())
    if files: return files[0]

#Cell
def safe_rename(file, dest):
    to_name = dest/file.name
    if to_name.exists():
        u = uuid4()
        to_name = dest/f'{name}-{u}'
        warnings.warn(f'Using unique name {to_name}')
    file.replace(to_name)
    return to_name

#Cell
class ResourcePoolBase():
    def __init__(self, path):
        self.path = Path(path)
        self.path.mkdir(exist_ok=True)

    def _lockpath(self,ident): return self.path/f'{ident}.lock'
    def _is_locked(self,ident): return self._lockpath(ident).exists()
    def lock(self,ident): self._lockpath(ident).write_text(str("locked"))
    def unlock(self,ident): return self._lockpath(ident).unlink() if self._is_locked(ident) else None
    def is_available(self,ident): return not self._is_locked(ident)
    def all_ids(self): raise NotImplementedError
    def find_next(self): return first(o for o in self.all_ids() if self.is_available(o))
    def lock_next(self):
        ident = self.find_next()
        if ident is None: return
        self.lock(ident)
        return ident

    def _run(self, script, ident):
        failed = False
        with (path/'out'/f'{script.name}.stderr').open("w") as stderr:
            with (path/'out'/f'{script.name}.stdout').open("w") as stdout:
                try: res = subprocess.call(str(script), stdout=stdout, stderr=stderr)
                except: failed = True
        (path/'out'/f'{script.name}.exitcode').write_text(str(res))
        dest = path/'fail' if res or failed else path/'complete'
        finish_name = safe_rename(script, dest)
        self.unlock(ident)

    def run(self, script, ident):
        thread = Thread(target=self._run, args=(script, ident))
        thread.start()
        thread.join()

    def poll_scripts(self, poll_interval=0.1):
        for i in range(10):
            sleep(poll_interval)
            script = find_next_script(self.path/'to_run')
            if script is None: continue
            ident = self.lock_next()
            if ident is None: continue
            run_name = safe_rename(script, self.path/'running')
            self.run(run_name, ident)

#Cell
add_docs(ResourcePoolBase, "Base class for locked access to list of idents",
         unlock="Remove lockfile for `ident`",
         lock="Create lockfile for `ident`",
         is_available="Is `ident` available",
         all_ids="All idents (abstract method)",
         find_next="Finds next available resource, or None",
         lock_next="Locks an available resource and returns its ident, or None",
         run="Run `script` using resource `ident`",
         poll_scripts="Poll `to_run` for scripts and run in parallel on available resources")

#Cell
class FixedWorkerPool(ResourcePoolBase):
    "Vends locked access to fixed list of idents"
    def __init__(self, worker_ids, path):
        super().__init__(path)
        self.worker_ids = worker_ids

    def all_ids(self):
        "All available idents"
        return self.worker_ids

#Cell
class NVIDIAGPUs(ResourcePoolBase):
    "Vends locked access to NVIDIA GPUs"
    def __init__(self, path):
        super().__init__(path)
        pynvml.nvmlInit()
        self.device_count = pynvml.nvmlDeviceGetCount()

    def is_available(self,ident):
        "If a GPU's used_memory is less than 30M then it will be regarded as available"
        if not super().is_available(ident): return False
        device = pynvml.nvmlDeviceGetHandleByIndex(ident)
        meminfo = pynvml.nvmlDeviceGetMemoryInfo(device)
        return meminfo.used <= 30*1e6

    def all_ids(self):
        "All GPUs"
        return range(self.device_count)